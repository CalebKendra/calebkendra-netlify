[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computer Science 203 Blog",
    "section": "",
    "text": "Welcome to my website for Allegheny College’s Computer Science 203 - Software Development!\nThe following posts are a collection of articles I wrote throught our software development process\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\nSep 4, 2023\n\n\nSoftware Engineering at Google - 1\n\n\nProgramming Over Time\n\n\n\n\nSep 4, 2023\n\n\nFuzzing Book - 1\n\n\nIntroduction to Software Testing\n\n\n\n\nSep 11, 2023\n\n\nFuzzing Book - 2\n\n\nCoverage\n\n\n\n\nSep 13, 2023\n\n\nSoftware Engineering at Google - 2\n\n\nWhat is Software Engineering?\n\n\n\n\nSep 18, 2023\n\n\nSoftware Engineering at Google - 3\n\n\nHow to Work Well on Teams.\n\n\n\n\nSep 20, 2023\n\n\nFuzzing Book - 3\n\n\nFuzzing\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/fb3.html",
    "href": "posts/fb3.html",
    "title": "Fuzzing Book - 3",
    "section": "",
    "text": "Summary\nThis section discusses the use of “Fuzzers” or programs that create random sections of numbers, letters, and symbols in order to create a random test. We can use this program in order to test files for certain random inputs. Fuzzing checks help find many differnet errors and edge cases in software in order to make sure of your programs security and reliability. Many of the bugs that you fuzzers will find revolve around the the types of inputs that are given since many pieces of software has not tested all possible inputs but with a fuzzer it is alot easier to check a wide variety of commands. With this method we can test many different inputs very quickly by using a fuzzer.\n\n\nAction & Reflection\nThese fuzzing checks could be very usefull to impliment into our code because it would allow us to check many different types of texts at once. This could be very useful for chasten becasue this way we could check many different sections of code with many linting checks in order to make sure that chasten can find all these different types of text and inputs. In order for this to happen however, we would need to start seriously upping our testing as right now we dont have alot of testing going on to make sure that all of these things can be accounted for."
  },
  {
    "objectID": "posts/fb2.html",
    "href": "posts/fb2.html",
    "title": "Fuzzing Book - 2",
    "section": "",
    "text": "Summary\nIn order to make sure that a program can get as close to 100% code coverage as possible we use something called a fuzzing check. A fuzzing check generator of a random set of characters that allows us to check many different types of inputs. With these checks, we are able to create a range of possible results for different programs such as the example cgi_decode function that is shown to us. This allows us to check what inputs we need in order to get close to perfect code coverage with our tests.\n\n\nReflection\nHaving a test like this created seems very useful when it comes to checking to make sure you can achieve maximum coverage with random fuzzing inputs. This is a great way to find edge cases, especially in massive programs where there can be many many different inputs. This process however takes a lot of time so it is vital that this process is only done with large programs that cannot be manually checked in order to make sure that you are being most efficient with your time.\n\n\nAction Items\nFor our chasten project I believe that building these tests is very important for chasten especially since we are going to be adding many new features throughout the semester so it’s vital that we pass coverage before we ship this software out to the world. The problem with this I believe is that we are very very strict on time and we are already struggling to make it through the semester work, so if we were to start building these testing systems we would have to make the decision to dedicate a lot of class time to it."
  },
  {
    "objectID": "posts/se1.html",
    "href": "posts/se1.html",
    "title": "Software Engineering at Google - 1",
    "section": "",
    "text": "Summary\nIn the preface of “Software Engineering at Google” in the Programming Over Time section we are first introduced to the idea that “Software Engineering” is not just the act of creating code, but also the creation of processes that allow us to create maintainable and sustainable code. In this sense, when we release a version of the software we created, we don’t want that software to be the final version but rather a building block upon which we can improve. In order to succeed in this goal of sustainability the book is going to emphasize three points to be thinking of while creating software:\n\nTime - We need to plan out how the software we create will change from the start and finish of a certain project\nScale - We also need to plan how we will change our engineering methods as our team of engineers develops.\nCosts - Then we also need to decide on what parts of the project should be prioritized over others.\n\n\n\nReflection\nAs I think about how this section compares to chasten two main points jump out at me. For starters, the scaling of the project is going to be very important in order to make sure our code is created sustainably and on time. Since this project is being developed by a group of students who have for the most part never worked on a project at this scale or at this size of a team, plans are going to be have to laid out carefully. This is so everyone in our team stays on task and knows what they are doing as the project grows.\nThe other point I want to make is about the cost of certain features leading to decisions on what should be prioritized. This should also be something we should always be thinking of as well because we only have half a semester do work on chasten’s features and in order to make sure we deliver a functioning product we need to make sure that we are only working on the most important features.\n\n\nAction Items\nAfter reading this section it is clear to me that in big groups of software engineers, we need to be making a plan early on in order to make sure that every member of our team knows precisely what the plan for the codebase is. Then, adequate communication will allow our team to make quick decisions on what code should be made and how it should be made. On the other hand, it is clear to me that I need to quit keeping coding and software solutions to myself and should spread these to other people. This will allow for greater levels of communication between team members and will allow this project to succeed as a whole."
  },
  {
    "objectID": "posts/fb1.html",
    "href": "posts/fb1.html",
    "title": "Fuzzing Book - 1",
    "section": "",
    "text": "Summary\nIn the introductory section of the Fuzzing Book titled Introduction to Software Testing the main points that are discussed are about software testing and bug fixing. The first example given about software testing was with a square root function and how we would test this function in order to make sure it gives correct ouputs. The first test they gave was that we could multiply two square root functions together with the same input in both as they should be able to give the input value back, and while this test works, it is not replicatable on a large scale and is not efficient. In order to make this process faster the book then decides to automate testing by using an assert command in order to make sure that the output given from the function is the same as expected. that solution is not bad, but further code is needed in order to make sure that the floating point values work right. to combat this we introduce a epsilon value that ensures there were no rounding errors in the code, and we make this test easily useable by putting it inside a function. This makes it easy to test and confirm that tens of thousands of values are correct all at the same time by iterating through a large group of random numbers.\nThe next part of this chapter talks about how we can build test functions into already existing code in order to intuitively check for bugs or misinputs. This includes using try and except statements in order to see if certain errors occur when a certain part of a code is being run, this can tell us what the error is and display this information back to the user. pairing this bit of code with an assert statement allows us to correctly identify what errors our code is running into with certain inputs, and will allow us to more accurately identify an issue.\nFinally, although all these testing programs can be automated and can check for many different types of inputs and errors, there is no guarentee that your code is going to be fully free of errors as there are infinate amounts of inputs and scenarios that can change for your code reacts.\n\n\nReflection\nTesting is a very important process in software development that can be done with ease if the correct steps are put in place. For example, many different inputs must be tested in order to get a better idea of where a code is doing well and where it is failing. These steps can be automated in order to test many differnet inputs at once by using programs such as random in order to get a wide variety of results. tests can also be built into a program itself in order to check for errors as the code is being run to prevent things such as user error. Yet, in the end not all use cases can be tested fully as in every program there are always going to be edge cases of scenios that were not thought of, causing errors.\n\n\nAction Items\nFor me, testing is always something that I needed to improve upon and that was because I often skipped the testing process entierely in order to save time. But on large scale projects such as chasten, it is vital to run tests in order to make sure that the product we are delivering to the world has been tested so that our users are not effected even by the smallest bug that may occur in some scenarios. On the other hand, I have always been one to build edge case tests into my code in order to make sure that certain common errors were not present, such as type different on input to a function i created. I do this in order to make sure there is less user error when calling functions later in the code and this prevents major errors from reoccuring in my code."
  },
  {
    "objectID": "posts/se3.html",
    "href": "posts/se3.html",
    "title": "Software Engineering at Google - 3",
    "section": "",
    "text": "Summary\nThis section of the book Software Engineering at Google starts by talking about programmers and “The Genius Myth”. This is the idea that every programmer has in the back of their head where they think that they can hide their code away and work on it alone for months until one day they release it to the world to become famous for their brilliant code. The reality of the situation is that this is very improbable, programmers need to be able to not only work together but also be willing to make mistakes and show their thought processes to the world in order to get the best out of their software.\nOne of the biggest reasons to not keep your code private is that you need other people to see your ideas and give feedback on them. This will allow for new modifications to your code that could be vital for progress down the line. For example, if someone suggests a design change early on in the process then you could fix something that would be a major problem had you not fixed it early on. Another reason to not keep your code private is what’s called the bus factor, or the idea that one member of a team could leave suddenly. If this happens, and there is no documentation for the software that this person built, then the rest of the team is going to be stuck with a large section of code that nobody understands. Working in a group will remediate this problem as if multiple people have worked on the same code segment then you can easily pick up where others left off. Finally, a single person could be able to write thousands of lines of code in a day, but even someone that smart would not be able to make that code clean and testable all in one day. An entire team of software engineers would be able to write and test efficient code all at once. Working in a large team can also help alleviate bugs and other design flaws that someone writing many lines of code would not be able to do.\nNow that we are all on one page about working in a Software Engineering team, what do we do in this team? Well, there are three main pillars to be able to work socially with this team: Humility, Respect, and Trust. Being able to work for a team rather than for yourself is the key idea here, as every member of the team needs to be able to contribute to a project as one. One of the best ways to do this is to learn to take and give criticism about your work and others, this way you can improve and learn from your mistakes in order to not make them later on. In the same sense making mistakes is also one of the best ways to be better as a team as other people realizing you made a mistake can prove to be a valuable lesson to you in the future. Overall, being open to change and being willing to work with others are some of the best attributes you can have as a Software Engineer.\n\n\nAction & Reflection\nFor our current project, chasten, it is vital that we implement these ideas as we need to be able to work effectively together as a team. On that same hand, we need to make sure that our engineers are not working on projects alone without reaching out for help as they will run into all the same problems that the people in this book did. It is vital that as a team we share what we are doing and the mistakes we made so that as a team we can learn from these experiences. We need to stop being so private with what we are working on and create a larger schedule to make sure we know what everyone is doing and how we can help our colleagues out."
  },
  {
    "objectID": "posts/se2.html",
    "href": "posts/se2.html",
    "title": "Software Engineering at Google - 2",
    "section": "",
    "text": "Summary\nThe section What is Software Engineering in the book Software Engineering at Google goes over the basics and common misconceptions about what software engineering truly is. A good first example of this is the misconception that programming is the same as software engineering and this is simply not true. While software engineering does include programming, it mostly entails the planning behind how you will build sustainable software in a team. The major ideas you will be thinking about in this process include how big in scale this project will be, what features you want to prioritize first, or who you want to assign to each subject.\nThinking about how long a software engineering project will go on is one of the most important when thinking about the longevity of a project. For example, if a team wants to create a program that will last for decades they need to plan out the times they will work to upgrade that program as they know that this program will need to adapt to keep up with technology in the future. Another example of this is Hyrum’s law which states:\n\nWith a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody\n\nThis tells us that with enough users of an API, someone will be relying on the feature that you implemented into it. So if someone depends on every feature that you made, how can you change or upgrade them in the future? This is why you must strive to build code that is upgradeable so you can build upon previous updates to further flesh out features that you’ve made.\nAnother big distinction between software engineering and programming is the scale in which you have to change your codebase or engineers. Put simply, as a project grows or shrinks in size the scale in which your entire company needs to change as well. For example, if your company gains thousands of new customers, you are going to need to make sure your software processes can handle that level of growth alongside it. Another example of a scaling upgrade would be to the hardware that your engineers use which could increase productivity especially if those processes had not been updated in a long time. Yet not everything needs to scale as a company grows, for example, a feature or library your engineers use may be strong enough that it doesn’t matter the size of your company as It does the same work nonetheless.\nFinally, the idea of tradeoffs is massive in software engineering because it tells what we should allocate our precious resources to first. Tradeoffs are not just for deciding what software engineers should be programming with their time, but also for other costs such as financial and resource costs. A simple example of this would be the tradeoff that Google made to buy markers for their whiteboards. They decided that the financial cost was worth it to buy markers so their engineers could jot their ideas down on boards. A more complex example would be deciding on creating one feature vs. another feature if you only have time for one before a deadline, so software engineers have to think about that tradeoff to decide what is worth it and what is not.\n\n\nReflection\nThere are clearly some massive differences between software engineering and programming as programming is simply one small step in the massive software engineering puzzle. Software engineering encompasses so many high-level decisions that are made in order to give a piece of software sustainability in the short or long period of time it is active. Software should be able to respond to changes in many different factors such as scale, time, technology, and policy. These factors should all be accounted for when first building the code to ensure your code is maintainable in the future.\n\n\nAction Items\nI see this section relating to our code in CMPSC 203 as we need to start thinking about how the code changes we make now will affect us down the line when we wish to add new features and make chasten a better final product. In this sense, we also need to start writing more notes and planning out how we will make code adaptable to future updates. Another thing I believe we need to think about more is time trade-offs as we do not have a lot of time in class and so we need to be much more efficient with it."
  }
]