[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computer Science 203 Blog",
    "section": "",
    "text": "Welcome to my website for Allegheny College’s Computer Science 203 - Software Development!\nThe following posts are a collection of articles I wrote throught our software development process\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\nSep 4, 2023\n\n\nSoftware Engineering at Google - 1\n\n\nProgramming Over Time\n\n\n\n\nSep 4, 2023\n\n\nFuzzing Book - 1\n\n\nIntroduction to Software Testing\n\n\n\n\nSep 11, 2023\n\n\nFuzzing Book - 2\n\n\nCoverage\n\n\n\n\nSep 13, 2023\n\n\nSoftware Engineering at Google - 2\n\n\nWhat is Software Engineering?\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/fb2.html",
    "href": "posts/fb2.html",
    "title": "Fuzzing Book - 2",
    "section": "",
    "text": "Summary\nIn order to make sure that a program can get as close to 100% code coverage as possible we use something called a fuzzing check. A fuzzing check generator of a random set of characters that allows us to check many different types of inputs. With these checks, we are able to create a range of possible results for different programs such as the example cgi_decode function that is shown to us. This allows us to check what inputs we need in order to get close to perfect code coverage with our tests.\n\n\nReflection\nHaving a test like this created seems very useful when it comes to checking to make sure you can achieve maximum coverage with random fuzzing inputs. This is a great way to find edge cases, especially in massive programs where there can be many many different inputs. This process however takes a lot of time so it is vital that this process is only done with large programs that cannot be manually checked in order to make sure that you are being most efficient with your time.\n\n\nAction Items\nFor our chasten project I believe that building these tests is very important for chasten especially since we are going to be adding many new features throughout the semester so it’s vital that we pass coverage before we ship this software out to the world. The problem with this I believe is that we are very very strict on time and we are already struggling to make it through the semester work, so if we were to start building these testing systems we would have to make the decision to dedicate a lot of class time to it."
  },
  {
    "objectID": "posts/se1.html",
    "href": "posts/se1.html",
    "title": "Software Engineering at Google - 1",
    "section": "",
    "text": "Summary\nIn the preface of “Software Engineering at Google” in the Programming Over Time section we are first introduced to the idea that “Software Engineering” is not just the act of creating code, but also the creation of processes that allow us to create maintainable and sustainable code. In this sense, when we release a version of the software we created, we don’t want that software to be the final version but rather a building block upon which we can improve. In order to succeed in this goal of sustainability the book is going to emphasize three points to be thinking of while creating software:\n\nTime - We need to plan out how the software we create will change from the start and finish of a certain project\nScale - We also need to plan how we will change our engineering methods as our team of engineers develops.\nCosts - Then we also need to decide on what parts of the project should be prioritized over others.\n\n\n\nReflection\nAs I think about how this section compares to chasten two main points jump out at me. For starters, the scaling of the project is going to be very important in order to make sure our code is created sustainably and on time. Since this project is being developed by a group of students who have for the most part never worked on a project at this scale or at this size of a team, plans are going to be have to laid out carefully. This is so everyone in our team stays on task and knows what they are doing as the project grows.\nThe other point I want to make is about the cost of certain features leading to decisions on what should be prioritized. This should also be something we should always be thinking of as well because we only have half a semester do work on chasten’s features and in order to make sure we deliver a functioning product we need to make sure that we are only working on the most important features.\n\n\nAction Items\nAfter reading this section it is clear to me that in big groups of software engineers, we need to be making a plan early on in order to make sure that every member of our team knows precisely what the plan for the codebase is. Then, adequate communication will allow our team to make quick decisions on what code should be made and how it should be made. On the other hand, it is clear to me that I need to quit keeping coding and software solutions to myself and should spread these to other people. This will allow for greater levels of communication between team members and will allow this project to succeed as a whole."
  },
  {
    "objectID": "posts/fb1.html",
    "href": "posts/fb1.html",
    "title": "Fuzzing Book - 1",
    "section": "",
    "text": "Summary\nIn the introductory section of the Fuzzing Book titled Introduction to Software Testing the main points that are discussed are about software testing and bug fixing. The first example given about software testing was with a square root function and how we would test this function in order to make sure it gives correct ouputs. The first test they gave was that we could multiply two square root functions together with the same input in both as they should be able to give the input value back, and while this test works, it is not replicatable on a large scale and is not efficient. In order to make this process faster the book then decides to automate testing by using an assert command in order to make sure that the output given from the function is the same as expected. that solution is not bad, but further code is needed in order to make sure that the floating point values work right. to combat this we introduce a epsilon value that ensures there were no rounding errors in the code, and we make this test easily useable by putting it inside a function. This makes it easy to test and confirm that tens of thousands of values are correct all at the same time by iterating through a large group of random numbers.\nThe next part of this chapter talks about how we can build test functions into already existing code in order to intuitively check for bugs or misinputs. This includes using try and except statements in order to see if certain errors occur when a certain part of a code is being run, this can tell us what the error is and display this information back to the user. pairing this bit of code with an assert statement allows us to correctly identify what errors our code is running into with certain inputs, and will allow us to more accurately identify an issue.\nFinally, although all these testing programs can be automated and can check for many different types of inputs and errors, there is no guarentee that your code is going to be fully free of errors as there are infinate amounts of inputs and scenarios that can change for your code reacts.\n\n\nReflection\nTesting is a very important process in software development that can be done with ease if the correct steps are put in place. For example, many different inputs must be tested in order to get a better idea of where a code is doing well and where it is failing. These steps can be automated in order to test many differnet inputs at once by using programs such as random in order to get a wide variety of results. tests can also be built into a program itself in order to check for errors as the code is being run to prevent things such as user error. Yet, in the end not all use cases can be tested fully as in every program there are always going to be edge cases of scenios that were not thought of, causing errors.\n\n\nAction Items\nFor me, testing is always something that I needed to improve upon and that was because I often skipped the testing process entierely in order to save time. But on large scale projects such as chasten, it is vital to run tests in order to make sure that the product we are delivering to the world has been tested so that our users are not effected even by the smallest bug that may occur in some scenarios. On the other hand, I have always been one to build edge case tests into my code in order to make sure that certain common errors were not present, such as type different on input to a function i created. I do this in order to make sure there is less user error when calling functions later in the code and this prevents major errors from reoccuring in my code."
  },
  {
    "objectID": "posts/se2.html",
    "href": "posts/se2.html",
    "title": "Software Engineering at Google - 2",
    "section": "",
    "text": "Summary\nThe section What is Software Engineering in the book Software Engineering at Google goes over the basics and common misconceptions about what software engineering truly is. A good first example of this is the misconception that programming is the same as software engineering and this is simply not true. While software engineering does include programming, it mostly entails the planning behind how you will build sustainable software in a team. The major ideas you will be thinking about in this process include how big in scale this project will be, what features you want to prioritize first, or who you want to assign to each subject.\nThinking about how long a software engineering project will go on is one of the most important when thinking about the longevity of a project. For example, if a team wants to create a program that will last for decades they need to plan out the times they will work to upgrade that program as they know that this program will need to adapt to keep up with technology in the future. Another example of this is Hyrum’s law which states:\n\nWith a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody\n\nThis tells us that with enough users of an API, someone will be relying on the feature that you implemented into it. So if someone depends on every feature that you made, how can you change or upgrade them in the future? This is why you must strive to build code that is upgradeable so you can build upon previous updates to further flesh out features that you’ve made.\nAnother big distinction between software engineering and programming is the scale in which you have to change your codebase or engineers. Put simply, as a project grows or shrinks in size the scale in which your entire company needs to change as well. For example, if your company gains thousands of new customers, you are going to need to make sure your software processes can handle that level of growth alongside it. Another example of a scaling upgrade would be to the hardware that your engineers use which could increase productivity especially if those processes had not been updated in a long time. Yet not everything needs to scale as a company grows, for example, a feature or library your engineers use may be strong enough that it doesn’t matter the size of your company as It does the same work nonetheless.\nFinally, the idea of tradeoffs is massive in software engineering because it tells what we should allocate our precious resources to first. Tradeoffs are not just for deciding what software engineers should be programming with their time, but also for other costs such as financial and resource costs. A simple example of this would be the tradeoff that Google made to buy markers for their whiteboards. They decided that the financial cost was worth it to buy markers so their engineers could jot their ideas down on boards. A more complex example would be deciding on creating one feature vs. another feature if you only have time for one before a deadline, so software engineers have to think about that tradeoff to decide what is worth it and what is not.\n\n\nReflection\nThere are clearly some massive differences between software engineering and programming as programming is simply one small step in the massive software engineering puzzle. Software engineering encompasses so many high-level decisions that are made in order to give a piece of software sustainability in the short or long period of time it is active. Software should be able to respond to changes in many different factors such as scale, time, technology, and policy. These factors should all be accounted for when first building the code to ensure your code is maintainable in the future.\n\n\nAction Items\nI see this section relating to our code in CMPSC 203 as we need to start thinking about how the code changes we make now will affect us down the line when we wish to add new features and make chasten a better final product. In this sense, we also need to start writing more notes and planning out how we will make code adaptable to future updates. Another thing I believe we need to think about more is time trade-offs as we do not have a lot of time in class and so we need to be much more efficient with it."
  }
]