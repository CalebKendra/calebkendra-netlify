[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computer Science 203 Blog",
    "section": "",
    "text": "Welcome to my website for Allegheny College’s Computer Science 203 - Software Development!\nThe following posts are a collection of articles I wrote throught our software development process\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\nSep 4, 2023\n\n\nSoftware Engineering at Google - 1\n\n\nProgramming Over Time\n\n\n\n\nSep 4, 2023\n\n\nFuzzing Book - 1\n\n\nIntroduction to Software Testing\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/se1.html",
    "href": "posts/se1.html",
    "title": "Software Engineering at Google - 1",
    "section": "",
    "text": "Summary\nIn the preface of “Software Engineering at Google” in the Programming Over Time section we are first introduced to the idea that “Software Engineering” is not just the act of creating code, but also the creation of processes that allow us to create maintainable and sustainable code. In this sense, when we release a version of the software we created, we don’t want that software to be the final version but rather a building block upon which we can improve. In order to succeed in this goal of sustainability the book is going to emphasize three points to be thinking of while creating software:\n\nTime - We need to plan out how the software we create will change from the start and finish of a certain project\nScale - We also need to plan how we will change our engineering methods as our team of engineers develops.\nCosts - Then we also need to decide on what parts of the project should be prioritized over others.\n\n\n\nReflection\nAs I think about how this section compares to chasten two main points jump out at me. For starters, the scaling of the project is going to be very important in order to make sure our code is created sustainably and on time. Since this project is being developed by a group of students who have for the most part never worked on a project at this scale or at this size of a team, plans are going to be have to laid out carefully. This is so everyone in our team stays on task and knows what they are doing as the project grows.\nThe other point I want to make is about the cost of certain features leading to decisions on what should be prioritized. This should also be something we should always be thinking of as well because we only have half a semester do work on chasten’s features and in order to make sure we deliver a functioning product we need to make sure that we are only working on the most important features.\n\n\nAction Items\nAfter reading this section it is clear to me that in big groups of software engineers, we need to be making a plan early on in order to make sure that every member of our team knows precisely what the plan for the codebase is. Then, adequate communication will allow our team to make quick decisions on what code should be made and how it should be made. On the other hand, it is clear to me that I need to quit keeping coding and software solutions to myself and should spread these to other people. This will allow for greater levels of communication between team members and will allow this project to succeed as a whole."
  },
  {
    "objectID": "posts/fb1.html",
    "href": "posts/fb1.html",
    "title": "Fuzzing Book - 1",
    "section": "",
    "text": "Summary\nIn the introductory section of the Fuzzing Book titled Introduction to Software Testing the main points that are discussed are about software testing and bug fixing. The first example given about software testing was with a square root function and how we would test this function in order to make sure it gives correct ouputs. The first test they gave was that we could multiply two square root functions together with the same input in both as they should be able to give the input value back, and while this test works, it is not replicatable on a large scale and is not efficient. In order to make this process faster the book then decides to automate testing by using an assert command in order to make sure that the output given from the function is the same as expected. that solution is not bad, but further code is needed in order to make sure that the floating point values work right. to combat this we introduce a epsilon value that ensures there were no rounding errors in the code, and we make this test easily useable by putting it inside a function. This makes it easy to test and confirm that tens of thousands of values are correct all at the same time by iterating through a large group of random numbers.\nThe next part of this chapter talks about how we can build test functions into already existing code in order to intuitively check for bugs or misinputs. This includes using try and except statements in order to see if certain errors occur when a certain part of a code is being run, this can tell us what the error is and display this information back to the user. pairing this bit of code with an assert statement allows us to correctly identify what errors our code is running into with certain inputs, and will allow us to more accurately identify an issue.\nFinally, although all these testing programs can be automated and can check for many different types of inputs and errors, there is no guarentee that your code is going to be fully free of errors as there are infinate amounts of inputs and scenarios that can change for your code reacts.\n\n\nReflection\nTesting is a very important process in software development that can be done with ease if the correct steps are put in place. For example, many different inputs must be tested in order to get a better idea of where a code is doing well and where it is failing. These steps can be automated in order to test many differnet inputs at once by using programs such as random in order to get a wide variety of results. tests can also be built into a program itself in order to check for errors as the code is being run to prevent things such as user error. Yet, in the end not all use cases can be tested fully as in every program there are always going to be edge cases of scenios that were not thought of, causing errors.\n\n\nAction Items\nFor me, testing is always something that I needed to improve upon and that was because I often skipped the testing process entierely in order to save time. But on large scale projects such as chasten, it is vital to run tests in order to make sure that the product we are delivering to the world has been tested so that our users are not effected even by the smallest bug that may occur in some scenarios. On the other hand, I have always been one to build edge case tests into my code in order to make sure that certain common errors were not present, such as type different on input to a function i created. I do this in order to make sure there is less user error when calling functions later in the code and this prevents major errors from reoccuring in my code."
  }
]