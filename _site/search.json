[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computer Science 203 Blog",
    "section": "",
    "text": "Welcome to my website for Allegheny College’s Computer Science 203 - Software Development!\nThe following posts are a collection of articles I wrote throught our software development process\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\nSep 4, 2023\n\n\nSoftware Engineering at Google - 1\n\n\nProgramming Over Time\n\n\n\n\nSep 4, 2023\n\n\nFuzzing Book - 1\n\n\nIntroduction to Software Testing\n\n\n\n\nSep 11, 2023\n\n\nFuzzing Book - 2\n\n\nCoverage\n\n\n\n\nSep 13, 2023\n\n\nSoftware Engineering at Google - 2\n\n\nWhat is Software Engineering?\n\n\n\n\nSep 18, 2023\n\n\nSoftware Engineering at Google - 3\n\n\nHow to Work Well on Teams.\n\n\n\n\nSep 20, 2023\n\n\nFuzzing Book - 3\n\n\nFuzzing\n\n\n\n\nSep 26, 2023\n\n\nSoftware Engineering at Google - 4\n\n\nKnowledge Sharing\n\n\n\n\nSep 26, 2023\n\n\nFuzzing Book - 4\n\n\nMutation Analysis\n\n\n\n\nOct 11, 2023\n\n\nFuzzing Book - 5\n\n\nMutation Fuzzer\n\n\n\n\nOct 12, 2023\n\n\nSoftware Engineering at Google - 5\n\n\nEngineering for Equity\n\n\n\n\nOct 19, 2023\n\n\nSoftware Engineering at Google - 6\n\n\nHow to Lead a Team\n\n\n\n\nOct 19, 2023\n\n\nFuzzing Book - 6\n\n\nFuzzing with Grammer\n\n\n\n\nOct 26, 2023\n\n\nSoftware Engineering at Google - 7\n\n\nLeading at Scale\n\n\n\n\nOct 26, 2023\n\n\nFuzzing Book - 7\n\n\nEfficient Grammar Fuzzing\n\n\n\n\nNov 3, 2023\n\n\nSoftware Engineering at Google - 8\n\n\nStyle Guide and Rules\n\n\n\n\nNov 3, 2023\n\n\nFuzzing Book - 8\n\n\nParsing Inputs\n\n\n\n\nNov 13, 2023\n\n\nSoftware Engineering at Google - 9\n\n\nCode Review\n\n\n\n\nNov 13, 2023\n\n\nFuzzing Book - 9\n\n\nReducing Failure-Inducing Inputs\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/se7.html",
    "href": "posts/se7.html",
    "title": "Software Engineering at Google - 7",
    "section": "",
    "text": "Summary\nIn the previous chapter of Software Engineering at Google called How to Lead a Team we dealt with problems of being a manager and how to be come a good leader of a team. In this section we deal with the problems that come with leading a large team that can not be helped in detail but has to be done at a macro level. Most of the time as a large teams manager you will be responsible for leading your team through at a very high up level by making trade offs and decisions. There are a few ways that you can help your team move through an issue:\n\nIdentify the blinders that were previously holding your team back from innovating on a change.\nIdentify the trade offs for what should and shouldn’t be done.\nIterate through new ideas in order to continuely rebalance the trade offs to find what best fits.\n\nThe next goal you should have is to build a self driving team that is able to work on its own and you can leave without much side effect. This will minimize the bus factor, or the concept that you should minimize the amount of knowlage that will be lost of one person is hit by a bus and it out of work. This problem can be solved by creating subteams that tackle subproblems of a larger problem. This will ensure that each section of code has multiple people working on it and it able to be tackled with individual leaders, this was you are not the source of all knowledge for each problem.\nThe final point given is to always be scaling, or changing the size of your team in order to adjust for different time needs. Often you need to adapt to make sure that your team can fit in a certain deadline for a project depending on how big it may be. The biggest idea is to make sure that you are not overwhelming your team or yourselve while trying to tackle a big issue.\n\n\nAction & Reflection\nThe biggest idea I pulled from this section was the idea that:\n\nThis is what good management is about: 95% observation and listening, and 5% making critical adjustments in just the right place.\n\nThis idea can be applied to many different sections of management as you have to be able to not micromanage your teams every move as this will cause alot more disruption then its worth. Instead you should be lisening and watching what your team is doing and reacting based on that information that is given to you. This is a very worthwhile tip that allows your workers to be able to work but also to recieve key insights without their work being managed every day. This style will also allow you to see what your team needs and make key tradeoff and scaling decisions that will make your that your team can work as efficiently as possible.\nThis section does not apply to us in the chasten project a lot since it deals with leadership and we do not have a set leader that is suppost to give us tasks as we are suppost to give ourselves work to do. In a real work enviroment you would have a boss to tell each engineer what problem should be fixed but in our enviroment we are suppost to be working in small groups in order to fix issues or add feature on our own in order to create the chasten tool."
  },
  {
    "objectID": "posts/se2.html",
    "href": "posts/se2.html",
    "title": "Software Engineering at Google - 2",
    "section": "",
    "text": "Summary\nThe section What is Software Engineering in the book Software Engineering at Google goes over the basics and common misconceptions about what software engineering truly is. A good first example of this is the misconception that programming is the same as software engineering and this is simply not true. While software engineering does include programming, it mostly entails the planning behind how you will build sustainable software in a team. The major ideas you will be thinking about in this process include how big in scale this project will be, what features you want to prioritize first, or who you want to assign to each subject.\nThinking about how long a software engineering project will go on is one of the most important when thinking about the longevity of a project. For example, if a team wants to create a program that will last for decades they need to plan out the times they will work to upgrade that program as they know that this program will need to adapt to keep up with technology in the future. Another example of this is Hyrum’s law which states:\n\nWith a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody\n\nThis tells us that with enough users of an API, someone will be relying on the feature that you implemented into it. So if someone depends on every feature that you made, how can you change or upgrade them in the future? This is why you must strive to build code that is upgradeable so you can build upon previous updates to further flesh out features that you’ve made.\nAnother big distinction between software engineering and programming is the scale in which you have to change your codebase or engineers. Put simply, as a project grows or shrinks in size the scale in which your entire company needs to change as well. For example, if your company gains thousands of new customers, you are going to need to make sure your software processes can handle that level of growth alongside it. Another example of a scaling upgrade would be to the hardware that your engineers use which could increase productivity especially if those processes had not been updated in a long time. Yet not everything needs to scale as a company grows, for example, a feature or library your engineers use may be strong enough that it doesn’t matter the size of your company as It does the same work nonetheless.\nFinally, the idea of tradeoffs is massive in software engineering because it tells what we should allocate our precious resources to first. Tradeoffs are not just for deciding what software engineers should be programming with their time, but also for other costs such as financial and resource costs. A simple example of this would be the tradeoff that Google made to buy markers for their whiteboards. They decided that the financial cost was worth it to buy markers so their engineers could jot their ideas down on boards. A more complex example would be deciding on creating one feature vs. another feature if you only have time for one before a deadline, so software engineers have to think about that tradeoff to decide what is worth it and what is not.\n\n\nReflection\nThere are clearly some massive differences between software engineering and programming as programming is simply one small step in the massive software engineering puzzle. Software engineering encompasses so many high-level decisions that are made in order to give a piece of software sustainability in the short or long period of time it is active. Software should be able to respond to changes in many different factors such as scale, time, technology, and policy. These factors should all be accounted for when first building the code to ensure your code is maintainable in the future.\n\n\nAction Items\nI see this section relating to our code in CMPSC 203 as we need to start thinking about how the code changes we make now will affect us down the line when we wish to add new features and make chasten a better final product. In this sense, we also need to start writing more notes and planning out how we will make code adaptable to future updates. Another thing I believe we need to think about more is time trade-offs as we do not have a lot of time in class and so we need to be much more efficient with it."
  },
  {
    "objectID": "posts/se3.html",
    "href": "posts/se3.html",
    "title": "Software Engineering at Google - 3",
    "section": "",
    "text": "Summary\nThis section of the book Software Engineering at Google starts by talking about programmers and “The Genius Myth”. This is the idea that every programmer has in the back of their head where they think that they can hide their code away and work on it alone for months until one day they release it to the world to become famous for their brilliant code. The reality of the situation is that this is very improbable, programmers need to be able to not only work together but also be willing to make mistakes and show their thought processes to the world in order to get the best out of their software.\nOne of the biggest reasons to not keep your code private is that you need other people to see your ideas and give feedback on them. This will allow for new modifications to your code that could be vital for progress down the line. For example, if someone suggests a design change early on in the process then you could fix something that would be a major problem had you not fixed it early on. Another reason to not keep your code private is what’s called the bus factor, or the idea that one member of a team could leave suddenly. If this happens, and there is no documentation for the software that this person built, then the rest of the team is going to be stuck with a large section of code that nobody understands. Working in a group will remediate this problem as if multiple people have worked on the same code segment then you can easily pick up where others left off. Finally, a single person could be able to write thousands of lines of code in a day, but even someone that smart would not be able to make that code clean and testable all in one day. An entire team of software engineers would be able to write and test efficient code all at once. Working in a large team can also help alleviate bugs and other design flaws that someone writing many lines of code would not be able to do.\nNow that we are all on one page about working in a Software Engineering team, what do we do in this team? Well, there are three main pillars to be able to work socially with this team: Humility, Respect, and Trust. Being able to work for a team rather than for yourself is the key idea here, as every member of the team needs to be able to contribute to a project as one. One of the best ways to do this is to learn to take and give criticism about your work and others, this way you can improve and learn from your mistakes in order to not make them later on. In the same sense making mistakes is also one of the best ways to be better as a team as other people realizing you made a mistake can prove to be a valuable lesson to you in the future. Overall, being open to change and being willing to work with others are some of the best attributes you can have as a Software Engineer.\n\n\nAction & Reflection\nFor our current project, chasten, it is vital that we implement these ideas as we need to be able to work effectively together as a team. On that same hand, we need to make sure that our engineers are not working on projects alone without reaching out for help as they will run into all the same problems that the people in this book did. It is vital that as a team we share what we are doing and the mistakes we made so that as a team we can learn from these experiences. We need to stop being so private with what we are working on and create a larger schedule to make sure we know what everyone is doing and how we can help our colleagues out."
  },
  {
    "objectID": "posts/fb6.html",
    "href": "posts/fb6.html",
    "title": "Fuzzing Book - 6",
    "section": "",
    "text": "Summary\nThis chapter intoduces the Grammer which is a way to map symbols in order to create string combinations in structured but randomized ways. This allows us to make complex but controlled string inputs that can be inputted in to different functions. For example:\nUS_PHONE_GRAMMAR: Grammar = {\n     \"&lt;start&gt;\": [\"&lt;phone-number&gt;\"],\n     \"&lt;phone-number&gt;\": [\"(&lt;area&gt;)&lt;exchange&gt;-&lt;line&gt;\"],\n     \"&lt;area&gt;\": [\"&lt;lead-digit&gt;&lt;digit&gt;&lt;digit&gt;\"],\n     \"&lt;exchange&gt;\": [\"&lt;lead-digit&gt;&lt;digit&gt;&lt;digit&gt;\"],\n     \"&lt;line&gt;\": [\"&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;\"],\n     \"&lt;lead-digit&gt;\": [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n     \"&lt;digit&gt;\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n}\nThis grammer defines a phone number creator which works by defining lead digits and digits for each of the three sections of a phone number, then sets the lead digit and digit to be 2-9 and 0-9, respectively. This creates a set but random number generator in a consise and easy to read way in order to generate random inputs.\nThis can be used in certain ways such as inputting grammers into mutation fuzzing in order to specifiy better seed inputs such as with:\nfrom MutationFuzzer import MutationFuzzer\nnumber_of_seeds = 10\nseeds = [\n    simple_grammar_fuzzer(\n        grammar=URL_GRAMMAR,\n        max_nonterminals=10) for i in range(number_of_seeds)]\nm = MutationFuzzer(seeds)\nThis function gives off 10 urls from URL_GRAMMAR which can then be placed into a mutation fuzzer that can cause bugs in those seeded inputs. This allows us to create testable inputs from start to finish with a mutation fuzzer, allowing for a great amount of code coverage.\n\n\nAction & Reflection\nAs I said previously, the addition of grammars allows for the mutation fuzzing section we read before to be complete. Previously when we used mutation fuzzing we needed to give it a seeded input that was correct in order for it to change that input using mutation. Now with grammars we are able to create those seeded input automatically and then use them in mutation analysis in order to create a large amount of test inputs in order to test all the various inputs that our function could get. This process could be used for many things in chasten, the first thing that comes to mind is in the xpath expressions where a grammar for xpath expressions could be built then mutation analysis would be built from there."
  },
  {
    "objectID": "posts/fb8.html",
    "href": "posts/fb8.html",
    "title": "Fuzzing Book - 8",
    "section": "",
    "text": "Summary\nFor certain times when you are fuzzing a grammar fuzzer is not simply good enough to create one grammar as there are rules to the input you are putting in. The way we fix this is by using a parser in order to take a string input and turn it into a derivation tree. This can be done with a PED (predicate expression grammar) parser that will parse until it finds one rule that matches its query such as:\nclass PEGParser(Parser):\n    def parse_prefix(self, text):\n        cursor, tree = self.unify_key(self.start_symbol(), text, 0)\n        return cursor, [tree]\nThis would be fine, but in many cases we want to find all matches in which would would need a CFG (context-free grammar) parser. This allows for all parts of an input to be matched while parsing such as:\nclass CFGParser(CGFParser):\n    def parse(self, text):\n        cursor, states = self.parse_prefix(text)\n        start = next((s for s in states if s.finished()), None)\n\n        if cursor &lt; len(text) or not start:\n            raise SyntaxError(\"at \" + repr(text[cursor:]))\n\n        forest = self.parse_forest(self.table, start)\n        for tree in self.extract_trees(forest):\n            yield self.prune_tree(tree)\n\n\nAction & Reflection\nThese parsers are the best next step to be able to easily create deriviation trees from certain seeded inputs. This allows us to know what grammars are needed to be able to simulate inputs for future fuzzing testing. This further automates the taking of inputs to be able to fuzz future inputs.\nThis can be used in chasten by the utilizing PED and CFG to enhance the tool’s performance by importing and easily implementing these parsers. These parsers create concise branched grammars, resulting in faster grammar processing times. integrating more complex parsers, allows for the composition of grammars and the introduction of finer details without impacting external structures or significance in the program."
  },
  {
    "objectID": "posts/fb2.html",
    "href": "posts/fb2.html",
    "title": "Fuzzing Book - 2",
    "section": "",
    "text": "Summary\nIn order to make sure that a program can get as close to 100% code coverage as possible we use something called a fuzzing check. A fuzzing check generator of a random set of characters that allows us to check many different types of inputs. With these checks, we are able to create a range of possible results for different programs such as the example cgi_decode function that is shown to us. This allows us to check what inputs we need in order to get close to perfect code coverage with our tests.\n\n\nReflection\nHaving a test like this created seems very useful when it comes to checking to make sure you can achieve maximum coverage with random fuzzing inputs. This is a great way to find edge cases, especially in massive programs where there can be many many different inputs. This process however takes a lot of time so it is vital that this process is only done with large programs that cannot be manually checked in order to make sure that you are being most efficient with your time.\n\n\nAction Items\nFor our chasten project I believe that building these tests is very important for chasten especially since we are going to be adding many new features throughout the semester so it’s vital that we pass coverage before we ship this software out to the world. The problem with this I believe is that we are very very strict on time and we are already struggling to make it through the semester work, so if we were to start building these testing systems we would have to make the decision to dedicate a lot of class time to it."
  },
  {
    "objectID": "posts/se5.html",
    "href": "posts/se5.html",
    "title": "Software Engineering at Google - 5",
    "section": "",
    "text": "Summary\nThis section talks about how engineers often don’t account for other types of people when considering how to build software. It is important that engineers not only know how to code but also to be morally concious about what they make. It is important for engineers to consider that the tools they build may take lots of sensitive data that could be effecting millions of people. It is not only the responsability of the employers but also the employees to make sure that there is a focus on product equity to users over profit margins to shareholders in order to promote underepresented groups.\nIt is not only good enough to make sure that an equitable amount of different people are hired to each company but it is also vital to make sure that each member of these companies is in an equal working enviroment. For example, a company needs to do more then just make sure they hire enough women, but they also need to make sure that they will have a comfortable and inclusive working enviroment at least on par with all other members of that company. Overall, a better work enviroment for all will lead to a more positive and productive experience for all involved and so it is vital that all are accomidated.\n\n\nAction & Reflection\nFrom this section I can see that it is vital to accomidate all people in order to best accomidate groups that have not been as well accomidated. discrimination based on traits leads to a negative and less productive enviroment that will lead to underpreforming members. This is why it is best to accomidate all people in order to best build a strong enviroment for all people to thrive at your company and break down structural biases that are common in society. In our project we can bring in many of these practices to allow for people who may not have fit in with the current structure of work and allow those people to be successfull."
  },
  {
    "objectID": "posts/se8.html",
    "href": "posts/se8.html",
    "title": "Software Engineering at Google - 8",
    "section": "",
    "text": "Summary\nThis section of Software Engineering at Google talks about rules and where they should be applied in order to get the best out of your code. Rules help place guidelines on what should be encouraged and what should be left out. These guidelines also help a company reflect on certain decisions that they value in order to help place those guidelines on their workers.\nWithout a good rule set, codebases become unmanageable and have no organizable pattern so it is vital to be able to standardize how your project and company is run. One of the best ways to do this is to write a style guide to ensure that everyone at a company is on the same page when it comes to how programs should be carried out.\nOverall, creating a strong set of rules that can be easily followed but also allow for a consistant set of policys in your workplace is vital. Rules will become the basis of how your team goes about future project and will allow for stead production into the future.\n\n\nAction & Reflection\nThis section applies to our chasten project a lot since alot of the time our team is not on the same page and so having a consise set of rules could help alot. For instance, if we had more rules pertaining to how pull requests are approved and how work should be done then we could have a much more consistant and efficient team that can make detailed changes faster. Changes like this would put everyone on our team on the same page without having to go through a cumbersome process to beg team members to help with certain aspects of team based software engineering."
  },
  {
    "objectID": "posts/fb9.html",
    "href": "posts/fb9.html",
    "title": "Fuzzing Book - 9",
    "section": "",
    "text": "Summary\nThis section of Fuzzing Book deals with ideas based around cutting down on the size of mutated inputs so that users can more easily identify what inputs cause errors. This means that very long and confusing inputs can be made into simple statements that show what inputs cause errors. For example a fuzzed input could look something like this at its full length:\n7:,&gt;((/$$-/-&gt;.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69\\':\\'&lt;3+0-3.24#7=!&60)2/+\";+&lt;7+1&lt;2!4$&gt;92+$1&lt;(3%&5\\'\\'&gt;#\nIf this statement were to give an error messege after testing it would be difficult to find out what section the error occured in. This is where  delta debugging  comes into place as we are able to cut down on this input until it looks something like this:\nTest #1 ' 7:,&gt;((/$$-/-&gt;.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69\\':\\'&lt;3+0-3.24#7=!&60)2/+\";+&lt;7+1&lt;2!4$&gt;92+$1&lt;(3%&5\\'\\'&gt;#' 97 FAIL\nTest #2 '\\'&lt;3+0-3.24#7=!&60)2/+\";+&lt;7+1&lt;2!4$&gt;92+$1&lt;(3%&5\\'\\'&gt;#' 49 PASS\nTest #3 \" 7:,&gt;((/$$-/-&gt;.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69':\" 48 PASS\nTest #4 '50#7*8=$&&=$9!%6(4=&69\\':\\'&lt;3+0-3.24#7=!&60)2/+\";+&lt;7+1&lt;2!4$&gt;92+$1&lt;(3%&5\\'\\'&gt;#' 73 FAIL\nTest #5 \"50#7*8=$&&=$9!%6(4=&69':&lt;7+1&lt;2!4$&gt;92+$1&lt;(3%&5''&gt;#\" 49 PASS\nTest #6 '50#7*8=$&&=$9!%6(4=&69\\':\\'&lt;3+0-3.24#7=!&60)2/+\";+' 48 FAIL\nTest #7 '\\'&lt;3+0-3.24#7=!&60)2/+\";+' 24 PASS\nTest #8 \"50#7*8=$&&=$9!%6(4=&69':\" 24 PASS\nTest #9 '9!%6(4=&69\\':\\'&lt;3+0-3.24#7=!&60)2/+\";+' 36 FAIL\nTest #10 '9!%6(4=&69\\':=!&60)2/+\";+' 24 FAIL\nTest #11 '=!&60)2/+\";+' 12 PASS\nTest #12 \"9!%6(4=&69':\" 12 PASS\nTest #13 '=&69\\':=!&60)2/+\";+' 18 PASS\nTest #14 '9!%6(4=!&60)2/+\";+' 18 FAIL\nTest #15 '9!%6(42/+\";+' 12 PASS\nTest #16 '9!%6(4=!&60)' 12 FAIL\nTest #17 '=!&60)' 6 PASS\nTest #18 '9!%6(4' 6 PASS\nTest #19 '6(4=!&60)' 9 FAIL\nTest #20 '6(460)' 6 FAIL\nTest #21 '60)' 3 PASS\nTest #22 '6(4' 3 PASS\nTest #23 '(460)' 5 FAIL\nTest #24 '460)' 4 PASS\nTest #25 '(0)' 3 FAIL\nTest #26 '0)' 2 PASS\nTest #27 '(' 1 PASS\nTest #28 '()' 2 FAIL\nTest #29 ')' 1 PASS\n'()'\nIn this case we were able to shrink the input by using a divide and conquer method in order to find what specific section of code is causing the failure.\nWhile this method works for long strings, there are some inputs that this method does not work with. For example if we were working with inputs as mathmatical expressions then delta debugging would cut out key parts of equations. This is where we could introduce  grammars and derivation trees  in order to define each section of an input and parse it down find where the failure is. With an input of:\n1 + (2 * 3)\nThis would look something like:\nTest #1 '(2 * 3)' 7 FAIL\nTest #2 '(3)' 3 FAIL\nTest #3 '3' 1 PASS\n'(3)'\nThis section showed us that our reducer is able to quickly find the statement inside of the equation without cutting it in half as it is able to identify the sections of the expressions that are connected with grammars.\n\n\nAction & Reflection\nWhen using fuzzing inputs its great to see that there is a way to quickly find the sections of inputs that cause errors are this is a great way to be able to save even more time while using test cases. To be able to run tests and find exactly where your function will give an error massively cuts down on one of the biggest issues with fuzzing and that is the time that it takes to fix the many errors it gives. Identification of these specific problems allows us to come up with broader solutions to problems, leading to smarter solutions that last."
  },
  {
    "objectID": "posts/se1.html",
    "href": "posts/se1.html",
    "title": "Software Engineering at Google - 1",
    "section": "",
    "text": "Summary\nIn the preface of “Software Engineering at Google” in the Programming Over Time section we are first introduced to the idea that “Software Engineering” is not just the act of creating code, but also the creation of processes that allow us to create maintainable and sustainable code. In this sense, when we release a version of the software we created, we don’t want that software to be the final version but rather a building block upon which we can improve. In order to succeed in this goal of sustainability the book is going to emphasize three points to be thinking of while creating software:\n\nTime - We need to plan out how the software we create will change from the start and finish of a certain project\nScale - We also need to plan how we will change our engineering methods as our team of engineers develops.\nCosts - Then we also need to decide on what parts of the project should be prioritized over others.\n\n\n\nReflection\nAs I think about how this section compares to chasten two main points jump out at me. For starters, the scaling of the project is going to be very important in order to make sure our code is created sustainably and on time. Since this project is being developed by a group of students who have for the most part never worked on a project at this scale or at this size of a team, plans are going to be have to laid out carefully. This is so everyone in our team stays on task and knows what they are doing as the project grows.\nThe other point I want to make is about the cost of certain features leading to decisions on what should be prioritized. This should also be something we should always be thinking of as well because we only have half a semester do work on chasten’s features and in order to make sure we deliver a functioning product we need to make sure that we are only working on the most important features.\n\n\nAction Items\nAfter reading this section it is clear to me that in big groups of software engineers, we need to be making a plan early on in order to make sure that every member of our team knows precisely what the plan for the codebase is. Then, adequate communication will allow our team to make quick decisions on what code should be made and how it should be made. On the other hand, it is clear to me that I need to quit keeping coding and software solutions to myself and should spread these to other people. This will allow for greater levels of communication between team members and will allow this project to succeed as a whole."
  },
  {
    "objectID": "posts/fb7.html",
    "href": "posts/fb7.html",
    "title": "Fuzzing Book - 7",
    "section": "",
    "text": "Summary\nIn this section we discuss the fact that, the old function we used in Fuzzing Book called simple_grammar_fuzzer was was first of all not very efficient and the time complexity was very bad when dealing with large inputs, and secondly was often incorrect with the amount of symbols or parathases that it gave off. In order to fix this we can start by building something called a deviation tree which tracks the pathways that the grammars take in order to create thier final output. We can use these deviation trees to be able to track the costs of each grammar statement. This allows us to set the amount of times that we want the grammar to expand and when we want the grammer to cut back and end. This allows us to set the size of the input rather then have a random size input. This allows us to control the time that is taken to evaluate all these inputs as you are able to limit the size that is being fed into the function.\n\n\nAction & Reflection\nThe addition of deviation trees allows for the limitation of the size of grammar fuzzing which allows it to become a viable testing technique as it is able to control the size of the input. Without this limitation the grammar fuzzing could go on forever which would take a lot more time then without them as the inputs would be much smaller. Overall this change would be greate for using in inputs as you would be able to confirm that your inputs will not be super long and will be able to be done in time."
  },
  {
    "objectID": "posts/fb1.html",
    "href": "posts/fb1.html",
    "title": "Fuzzing Book - 1",
    "section": "",
    "text": "Summary\nIn the introductory section of the Fuzzing Book titled Introduction to Software Testing the main points that are discussed are about software testing and bug fixing. The first example given about software testing was with a square root function and how we would test this function in order to make sure it gives correct ouputs. The first test they gave was that we could multiply two square root functions together with the same input in both as they should be able to give the input value back, and while this test works, it is not replicatable on a large scale and is not efficient. In order to make this process faster the book then decides to automate testing by using an assert command in order to make sure that the output given from the function is the same as expected. that solution is not bad, but further code is needed in order to make sure that the floating point values work right. to combat this we introduce a epsilon value that ensures there were no rounding errors in the code, and we make this test easily useable by putting it inside a function. This makes it easy to test and confirm that tens of thousands of values are correct all at the same time by iterating through a large group of random numbers.\nThe next part of this chapter talks about how we can build test functions into already existing code in order to intuitively check for bugs or misinputs. This includes using try and except statements in order to see if certain errors occur when a certain part of a code is being run, this can tell us what the error is and display this information back to the user. pairing this bit of code with an assert statement allows us to correctly identify what errors our code is running into with certain inputs, and will allow us to more accurately identify an issue.\nFinally, although all these testing programs can be automated and can check for many different types of inputs and errors, there is no guarentee that your code is going to be fully free of errors as there are infinate amounts of inputs and scenarios that can change for your code reacts.\n\n\nReflection\nTesting is a very important process in software development that can be done with ease if the correct steps are put in place. For example, many different inputs must be tested in order to get a better idea of where a code is doing well and where it is failing. These steps can be automated in order to test many differnet inputs at once by using programs such as random in order to get a wide variety of results. tests can also be built into a program itself in order to check for errors as the code is being run to prevent things such as user error. Yet, in the end not all use cases can be tested fully as in every program there are always going to be edge cases of scenios that were not thought of, causing errors.\n\n\nAction Items\nFor me, testing is always something that I needed to improve upon and that was because I often skipped the testing process entierely in order to save time. But on large scale projects such as chasten, it is vital to run tests in order to make sure that the product we are delivering to the world has been tested so that our users are not effected even by the smallest bug that may occur in some scenarios. On the other hand, I have always been one to build edge case tests into my code in order to make sure that certain common errors were not present, such as type different on input to a function i created. I do this in order to make sure there is less user error when calling functions later in the code and this prevents major errors from reoccuring in my code."
  },
  {
    "objectID": "posts/fb4.html",
    "href": "posts/fb4.html",
    "title": "Fuzzing Book - 4",
    "section": "",
    "text": "Summary\nThe section mutation analysis covers the idea of creating programs that can test our test cases. Often we will find that ineffective testing can cause 100% test coverage but at the same time will be because of ineffective testing that means our tests ability to catch bugs is actually 0%. In order to fix this we can create mutation analysis programs that edit our code to create temporary but effective errors in order to test our test cases ability to find bugs.\nIn the examples given in this article they test a triangle program and its ability to detect the triangle category based on the length of three inputted sides of a triangle. To analysize test cases in this function they first standardise the program by parsing and unparsing it in order to standardize the format of the function in a process called mutation. From there the analysis begins when return statements are replaced with pass statements. This should give an error as then certain categories of triangles will not be found when they should, causing an error. This program can then be run with each return statement individually in order to determine how accurate these test cases are for determining code coverage.\nThe last section of this chapter talks about equivilent mutants which are faulty mutations in tested functions that essentially do the same as the base function. This means that these mutations will inflate the test coverage as they will never give off an error thats different from the original function. However, the amount of these false tests can be accounted for with statistical probability and so we can take into account that a certain percentage of cases will be faulty when we make our final code coverage calculations.\n\n\nAction & Reflection\nFor me, this article is something we could take into account into the chasten project for sure as we need to make sure that the test coverage can account for any different input that a user could potentally input with XPATH expressions. And so for this reason I find it vital to be able to make sure that our test cases are secure and can find many different errors and the best and most efficient way for us to check this is mutation analysis. Another point I would like to make is that many outside functions seem to do a lot of the hardest steps in mutation analysis for us and so implimenting these into your software would be a very easy way to improve the quality of your code overall."
  },
  {
    "objectID": "posts/fb5.html",
    "href": "posts/fb5.html",
    "title": "Fuzzing Book - 5",
    "section": "",
    "text": "Summary\nWhen attempting to fuzz programs that can accept more then just random inputs such as a website url, it is vital that we change our fuzzer in order to create realistic looking but incorrect urls in order to test a function based around website urls. If we try to pass random inputs into a function such as this it could take years in order to get a correct http url in order to correctly test the function. A good way to change inputs would be to take correct inputs and change certain characters around to make the url incorrect but very close to being correct.\nUsing this strategy, we are able to create many different variations of inputs, then, when we pair these many inputs with a runner function we are able to make sure that every line of the tested function is covered. Combining all these ideas into a mutation fuzzing function allows us to combine all the previous tasks we learned in mutation analysis, code coverage, and fuzzing.\n\n\nAction & Reflection\nThis article discusses the combination of all of the previous information that we learned and applies it to one function called mutation fuzzing. It is vital that we start implimenting these ideas into our test cases in order to make sure that all the differenet types of XPATH expressions are covered. With mutation fuzzing we can apply these things very quickly at a massive scale in order to impliement tests that we could never do outselves if we were tests on our own."
  },
  {
    "objectID": "posts/se6.html",
    "href": "posts/se6.html",
    "title": "Software Engineering at Google - 6",
    "section": "",
    "text": "Summary\nThis section in Software Engineering at Google recognizes the need to have a leader for every team as a team is nothing without someone to steer them in the right direction. With the manager of a software developer team being such a important role, engineers who never expected or wanted to go into management find themselves either directly or indirectly in these positions. This is why it is important to learn how to not only be a good software engineer, but also how to manage a team of engineers.\nOne of the big first points that are made are about trying not to over manage your team when you are managing. You don’t want to be micromanaging and making your engineers lives harder, so it is better to focus on making the lives of your engineers smoother. Instead of harming and squeezing the most our of your workers, it is more productive to give your workers time and space in order to create a positive work enviroment. One way of doing this is to give your workers the leeway in order to work whenever they want as long as they are getting their work done, allowing for workers to work on their own time schedule. Another big concept is to not be a friend to all of your workers as you will have to give them hard information and make sure they are keeping on task. Being a positive, calm, and down-to-earth manager helps you work with your workers in order to be a great resource for people to use. This will help you break down roadblocks and make the process easier for workers to focus on work instead of outside problems. These ideas culminate in three main ideas of:\n\nHumility\nTrust\nRespect\n\nIf you follow these three main ideas you will help all your workers by being a strong source that can be relied on and allow your workers to focus on the task at hand rather then worrying about their manager.\n\n\nAction & Reflection\nWe do not have any direct leaders of certain groups, but as a team we do have to lead each other in certain projects especially when we are specialiced in certain parts of the code and we have to share this with others. That being said, there is not a power structure like manager down to worker such as in a big buisness and so many of the power structure ideas do not apply here. However, we can still be respectfull and make sure to be humble when dealing wiht people who are less prepared or knowledgeable about a certain topic then us, this will allow for better knowledge transfer."
  },
  {
    "objectID": "posts/fb3.html",
    "href": "posts/fb3.html",
    "title": "Fuzzing Book - 3",
    "section": "",
    "text": "Summary\nThis section discusses the use of “Fuzzers” or programs that create random sections of numbers, letters, and symbols in order to create a random test. We can use this program in order to test files for certain random inputs. Fuzzing checks help find many differnet errors and edge cases in software in order to make sure of your programs security and reliability. Many of the bugs that you fuzzers will find revolve around the the types of inputs that are given since many pieces of software has not tested all possible inputs but with a fuzzer it is alot easier to check a wide variety of commands. With this method we can test many different inputs very quickly by using a fuzzer.\n\n\nAction & Reflection\nThese fuzzing checks could be very usefull to impliment into our code because it would allow us to check many different types of texts at once. This could be very useful for chasten becasue this way we could check many different sections of code with many linting checks in order to make sure that chasten can find all these different types of text and inputs. In order for this to happen however, we would need to start seriously upping our testing as right now we dont have alot of testing going on to make sure that all of these things can be accounted for."
  },
  {
    "objectID": "posts/se4.html",
    "href": "posts/se4.html",
    "title": "Software Engineering at Google - 4",
    "section": "",
    "text": "Summary\nIn software development, It is curcial that you learn how to communicatae your issues within your own team because those team members are more likely to know the solution as they are working on the same project as you. This can be difficult for a number of reasons however such as fear of making a mistake, a single member not sharing their section of the codebase, or large broken sections of code to name a few.\nThere are a few different ways we can look to solve this problem and they all revolve around forms of communication. The best form of this communication has a large level of documentation paried with individuals who can apply this information to individuals and their needs. This allows for lots of information to be stored but also for individuals with problems to have coworkers ready to help them for their unique case. With these levels of communication in place we also need to give room for individuals to feel comfortable asking questions, and thats why its important to assign new members with mentors to be able to have one on one interaction with and ask questions. This will allow for new memebers of the team to grow into their role and eventually mentor others as they have the ability to ask questions through various platforms.\nOverall, to have a successfull level of communication as a software engineering team you need to make information and mentorship easy and comfortable to access. New members need to feel comfortable going up to higher level engineers and asking questions so they too can become become familar with the system. Finally, there is no one solution to communication because although methods like documentation are great, communicating effectively with others requires multiple levels of information that vary between online and in person services in order to make information flow effectively.\n\n\nAction & Reflection\nThis article is very important for the work we are doing on chasten as we need to be able to communicate effectively in the small amount of time we have together each week. Overall we have done an okay job of this but I beleive we could improve on these with a few changes. Alot of time when working on chasten I believe we struggle to make information widely avaliable especially when it comes to our individual pull requests and issues, this can cause alot of problems for a few reasons. For one, this information will be lost if a member is sick or leaves the team and we will have to start again from scratch. Then, even if the issue is solved by this single person, others will still have to review the information. This means that if an error was present from the start of the change, then the pull request will have to be scrapped and potentally redone. To fix problems like this, we should greate smaller teams that allow for members to discuss the changes they are making and find a solution to these problems."
  },
  {
    "objectID": "posts/se9.html",
    "href": "posts/se9.html",
    "title": "Software Engineering at Google - 9",
    "section": "",
    "text": "Summary\nThis section of Software Engineering at Google deals with the reviewing of code before it is merged to the main product. This has to do with the benefits, tips, and overall process that Google has in order to ensure that code review is done as efficiently and effectively as possible. Google uses a very detailed method in order to ensure correctness, consistency, a high level of knowledge sharing between developers, and a large record to be able to track changes made. While this process is costly, it ensures that the codebase maintains a level of consistancy that is up to Googles standards.\nThe code review practice is not always smooth sailing however, and so this section also gave a few tips on how to produce reviews effectively. For one, polite and professional communication is required in order to make sure code is reviewed on time and without argument. Code reviewers should make sure to communicate when they are going to review and should do so in a timely fashion in order to not keep anyone waiting. Professionalism is also needed when a developer disagrees with a review on a particular section of code as both the reviewer and developer need to be able to come to an agreement on change should be made. Another great point is also to make sure you keep small changes in order to make sure that reviewers are not overwelmed and can review quickly. Writing good commit messeges and change descriptions also helps a lot for reviewers who need to know what exactly the change is doing. Not overusing resources when not needed is also very important and this can be achieved by only having a single reviewer as well as automating as many tasks as possible.\n\n\nAction & Reflection\nThis section brings up a lot of great points about how code review should be done efficiently. One that struck my eye was about the amount of reviewers on code as in our chasten project we have a minimum of 3 reviewers and sometimes we have up to 5 on a single change. This seems inefficient as the article said because a lot of the time reviewers will only skim through the code to ensure it works rather then actually taking time to see if it works, meaning that we have at least 3 people spending time half-heartedly reviewing code that could have been done by one person. On top of this it takes a lot of nagging to be able to make developers in our team review changes as not many developers check others quickly changes even when assigned. To fix this we could have reviews be done by just one person as this would mean that we would be able to hold this person responsible for not only completing this review on time but making sure that this change is done correctly.\nAnother point that intrigued me was about accurate change descriptions as I think this is something that our team is lacking in heavily, in particular commit messeges and timing. Our commits should be done very often in order to show each individual change to certain code segments as this would allow for reviewers to see each step that was took to improve and develop this change."
  }
]